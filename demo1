import { renderHook, waitFor } from "@testing-library/react";
import { useLoginMetadata } from "./hooks";
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient({
    defaultOptions: {
        queries: {
            retry: false
        }
    }
});

type WrapperType = {
    children: JSX.Element;
}

const wrapper: React.FC<WrapperType> = (props) => (
    <QueryClientProvider client={queryClient}>{props.children}</QueryClientProvider>
)

describe("useLoginMetadata", () => {
    // Mock fetch globally before running the tests
    beforeEach(() => {
        jest.spyOn(global, 'fetch').mockResolvedValueOnce({
            json: jest.fn().mockResolvedValueOnce({
                passwordLess: false,
                showRouterRearImage: true
            }),
            ok: true,
            headers: {
                get: () => "application/json", // Adjust content type if necessary
            },
            status: 200,
            statusText: "OK",
        });
    });

    // Restore fetch after each test
    afterEach(() => {
        jest.restoreAllMocks();
    });

    test("should return login metadata", async () => {
        const { result } = renderHook(() => useLoginMetadata(), { wrapper });

        await waitFor(() => expect(result.current.status).toBe("success"));

        expect(result.current.data).toEqual({
            passwordLess: false,
            showRouterRearImage: true
        });
    });

    test("should handle API error", async () => {
        // Mock the fetch function to simulate a 500 error
        global.fetch.mockResolvedValueOnce({
            ok: false,
            status: 500,
            statusText: "Internal Server Error",
            headers: {
                get: () => "text/html", // Adjust content type if necessary
            },
            text: jest.fn().mockResolvedValueOnce("Error message"),
        });

        const { result } = renderHook(() => useLoginMetadata(), { wrapper });

        await waitFor(() => expect(result.current.status).toBe("error"));

        expect(result.current.error).toEqual(new Error("Failed to fetch login metadata"));
    });
});








import { renderHook, waitFor } from "@testing-library/react";
import { useLoginMetadata } from "./hooks";
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient({
    defaultOptions: {
        queries: {
            retry: false
        }
    }
});

type WrapperType = {
    children: JSX.Element;
}

const wrapper: React.FC<WrapperType> = (props) => (
    <QueryClientProvider client={queryClient}>{props.children}</QueryClientProvider>
)

describe("useLoginMetadata", () => {
    // Mock fetch globally before running the tests
    beforeEach(() => {
        global.fetch = jest.fn();
    });

    // Restore fetch after each test
    afterEach(() => {
        jest.restoreAllMocks();
    });

    test("should return login metadata", async () => {
        const mockResponse = {
            passwordLess: false,
            showRouterRearImage: true
        };

        // Mock the fetch function to return the desired response
        global.fetch.mockResolvedValueOnce({
            json: jest.fn().mockResolvedValueOnce(mockResponse),
            ok: true,
            headers: {
                get: () => "application/json", // Adjust content type if necessary
            },
            status: 200,
            statusText: "OK",
        });

        const { result } = renderHook(() => useLoginMetadata(), { wrapper });

        await waitFor(() => expect(result.current.status).toBe("success"));

        expect(result.current.data).toEqual(mockResponse);
    });

    test("should handle API error", async () => {
        // Mock the fetch function to simulate a 500 error
        global.fetch.mockResolvedValueOnce({
            ok: false,
            status: 500,
            statusText: "Internal Server Error",
            headers: {
                get: () => "text/html", // Adjust content type if necessary
            },
            text: jest.fn().mockResolvedValueOnce("Error message"),
        });

        const { result } = renderHook(() => useLoginMetadata(), { wrapper });

        await waitFor(() => expect(result.current.status).toBe("error"));

        expect(result.current.error).toEqual(new Error("Failed to fetch login metadata"));
    });
});
the following error i am getting

Property 'mockResolvedValueOnce' does not exist on type '(input: RequestInfo | URL, init?: RequestInit | undefined) => Promise<Response>'.

import { mapAndThrowError } from "../api_error";
import { LOGIN_META_DATA_URL, LOGIN_TOKEN_URL, LOGIN_URL } from "../endpoints";
import { httpRequest } from "../http_client";
import {
  LoginMetadataResponse,
  LoginRequest,
  LoginResponse,
  LoginTokenResponse,
} from "./models";
import {
  LoginMetadataResponseSchema,
  LoginResponseSchema,
  LoginTokenResponseSchema,
} from "./schemas";

export async function getLoginMetadataApi(): Promise<LoginMetadataResponse> {
  try {
    const response = await httpRequest(LOGIN_META_DATA_URL).post().readAsJson();
    return LoginMetadataResponseSchema.parse(response) as LoginMetadataResponse;
  } catch (e) {
    mapAndThrowError(e);
  }
}

export async function getLoginTokenApi(): Promise<LoginTokenResponse> {
  try {
    const response = await httpRequest(LOGIN_TOKEN_URL)
      .contentLength(0)
      .post()
      .readAsJson();
    return LoginTokenResponseSchema.parse(response) as LoginTokenResponse;
  } catch (e) {
    mapAndThrowError(e);
  }
}

export async function loginApi(request: LoginRequest): Promise<LoginResponse> {
  try {
    const response = await httpRequest(LOGIN_URL)
      .jsonBody({ keepMeSignIn: request.keepMeSignIn })
      .headers({ username: request.userName, password: request.password })
      .post()
      .readAsJson();
    return LoginResponseSchema.parse(response) as LoginResponse;
  } catch (e) {
    mapAndThrowError(e);
  }
}
import { WretchError } from "wretch/resolver";
import { ZodError } from "zod";

export const STATUS_SCHEMA_VALIDATION_FAILED = 1;
export const STATUS_UNKNOWN_ERROR = 2;

export class ApiError extends Error {
  get isUnAuthorized(): boolean {
    return this.status === 401;
  }

  get isServerError(): boolean {
    return this.status === 500;
  }

  get isValidationError(): boolean {
    return this.status === STATUS_SCHEMA_VALIDATION_FAILED;
  }

  constructor(readonly status: number, readonly reason?: string) {
    super(reason);
  }
}

export function mapAndThrowError(e: unknown): never {
  if (e instanceof WretchError) {
    throw new ApiError(e.status, e.message);
  } else if (e instanceof ZodError) {
    throw new ApiError(STATUS_SCHEMA_VALIDATION_FAILED, e.message);
  } else if (e instanceof Error) {
    throw new ApiError(STATUS_UNKNOWN_ERROR, e.message);
  }
  throw new ApiError(STATUS_UNKNOWN_ERROR);
}
import wretch from "wretch";
import { Wretch, WretchResponseChain } from "wretch/types";

const WRETCH_INSTANCE = wretch();

class ClientWrapper {
  constructor(private wretch: Wretch) {}

  withoutCors(): ClientWrapper {
    this.wretch.options({ ...this.wretch.options, mode: undefined }, true);
    return this;
  }

  headers(headers: HeadersInit): ClientWrapper {
    this.wretch.headers(headers);
    return this;
  }

  contentLength(length: number): ClientWrapper {
    this.wretch.headers({
      ...this.wretch.headers,
      "content-length": length.toString(),
    });
    return this;
  }

  authToken(token: string): ClientWrapper {
    this.wretch.headers({
      ...this.wretch.headers,
      sessionAuth: token,
    });
    return this;
  }

  jsonBody(object: any): ClientWrapper {
    this.wretch.json(object);
    return this;
  }

  /**
   * Performs a POST request.
   */
  post(): ClientResponseWrapper {
    return new ClientResponseWrapper(this.wretch.post());
  }
}

class ClientResponseWrapper {
  constructor(
    private chain: WretchResponseChain<unknown, unknown, undefined>
  ) {}

  readAsJson<T>(): Promise<T> {
    return this.chain.json<T>();
  }

  readAsBlob(): Promise<Blob> {
    return this.chain.blob();
  }

  readRawResponse(): Promise<Response> {
    return this.chain.res();
  }
}

export function httpRequest(url: string): ClientWrapper {
  return new ClientWrapper(WRETCH_INSTANCE.options({ mode: "cors" }).url(url));
}
export type LoginMetadataResponse = {
  adminPwdChanged: boolean;
  passwordRequired: boolean;
};

export type LoginTokenResponse = {
  banTime: number;
  failedCount: number;
  md5Hashed: boolean;
  salt: string;
  timeRemaining: number;
};

export type LoginRequest = {
  userName: string;
  password: string;
  keepMeSignIn: boolean;
};

export type LoginResponse = {
  QSWPerformed: number;
  cookie: string;
  expiry: number;
};
import { z } from "zod";

export const LoginMetadataResponseSchema = z.object({
  adminPwdChanged: z.boolean(),
  passwordRequired: z.boolean(),
});

export const LoginTokenResponseSchema = z.object({
  banTime: z.number().nonnegative(),
  failedCount: z.number().nonnegative(),
  md5Hashed: z.boolean(),
  salt: z.string().min(1),
  timeRemaining: z.number().nonnegative(),
});

export const LoginResponseSchema = z.object({
  QSWPerformed: z.number().min(0).max(1),
  cookie: z.string().min(1),
  expiry: z.number().positive(),
});


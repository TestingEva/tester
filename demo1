That was good and is working fine 
now we need to add more validations to that 
create a sepreate function for each validations case 
first create them in the proper array format like for (number|[number,number]) format 
for example if there is 233,424-453,4532,2341,31-43,453,21-24 then it should come 
[233,[424,453],4532,2341,[31,43],453,[21,24]] and so on 

now for the case 1: if there is any array for example here we have [424,453] and start port is greater than or equal to  the end port then we need to return false 

case 2: if the port 4567 comes in the middle of the above ports then we need to return false 

case 3: if the port 4577 comes in the middle of the ports we need to return false 

To tackle this, let's break down the problem into three steps:

1. **Parse the port string into a structured array**.
2. **Implement the validation cases**:
    - **Case 1**: Ensure that in any port range `[start, end]`, `start` is less than `end`.
    - **Case 2**: Ensure that no port in the middle of the array is `4567`.
    - **Case 3**: Ensure that no port in the middle of the array is `4577`.

### Step 1: Parse the Port String

We'll first create a function to convert the port string into the desired array format:

```typescript
function parsePorts(ports: string): (number | [number, number])[] {
    return ports.split(',').map(port => {
        if (port.includes('-')) {
            const [start, end] = port.split('-').map(Number);
            return [start, end];
        }
        return Number(port);
    });
}

// Example usage
const portsArray = parsePorts("233,424-453,4532,2341,31-43,453,21-24");
console.log(portsArray); 
// Output: [233, [424, 453], 4532, 2341, [31, 43], 453, [21, 24]]
```

### Step 2: Implement the Validation Cases

Now, let's write functions for each of the three validation cases.

#### Case 1: Start Port Should Be Less Than End Port

```typescript
function validatePortRange(ports: (number | [number, number])[]): boolean {
    return ports.every(port => {
        if (Array.isArray(port)) {
            const [start, end] = port;
            return start < end; // Validation: start < end
        }
        return true;
    });
}
```

#### Case 2: No Port Should Be `4567`

```typescript
function validateNo4567(ports: (number | [number, number])[]): boolean {
    return ports.every(port => {
        if (Array.isArray(port)) {
            return !port.includes(4567); // Validation: port should not be 4567
        }
        return port !== 4567;
    });
}
```

#### Case 3: No Port Should Be `4577`

```typescript
function validateNo4577(ports: (number | [number, number])[]): boolean {
    return ports.every(port => {
        if (Array.isArray(port)) {
            return !port.includes(4577); // Validation: port should not be 4577
        }
        return port !== 4577;
    });
}
```

### Step 3: Combining Validations

You can now create a function that parses the input, applies all validations, and returns the final result:

```typescript
function validatePortsInput(ports: string): boolean {
    const parsedPorts = parsePorts(ports);
    
    // Apply all validation checks
    const isPortRangeValid = validatePortRange(parsedPorts);
    const hasNo4567 = validateNo4567(parsedPorts);
    const hasNo4577 = validateNo4577(parsedPorts);
    
    // Return true only if all validations pass
    return isPortRangeValid && hasNo4567 && hasNo4577;
}

// Example usage
const portsString = "233,424-453,4532,2341,31-43,453,21-24";
console.log(validatePortsInput(portsString)); // Output: true or false based on the validation checks
```

### Summary:
1. **`parsePorts`**: Converts the string to the array format.
2. **`validatePortRange`**: Ensures that `start` is less than `end` in any port range.
3. **`validateNo4567`**: Ensures no port in the middle is `4567`.
4. **`validateNo4577`**: Ensures no port in the middle is `4577`.
5. **`validatePortsInput`**: Combines all validations and checks the input.

This approach keeps your validation logic modular and easy to extend or modify as needed.
